import{_ as k,c as u,a as l,e as y,v as g,F as h,f as x,g as b,t as d,o as p}from"./index-CxvB7JRl.js";const c={data(){return{rows:3,cols:4,matrix:[],steps:[],currentStep:0,errorMessage:"",solution:[]}},methods:{createMatrix(){this.matrix=Array.from({length:this.rows},()=>Array(this.cols).fill(0)),this.steps=[],this.currentStep=0,this.errorMessage="",this.solution=[]},solveGaussJordan(){let i=JSON.parse(JSON.stringify(this.matrix)),t=i.length,f=i[0].length,v=[],s=new Set;const n=e=>Math.abs(e)<1e-10,r=e=>{v.push({matrix:JSON.parse(JSON.stringify(i)),action:e})};for(let e=0;e<t;e++){if(n(i[e][e])){let o=!1;for(let a=e+1;a<t;a++)if(!n(i[a][e])){[i[e],i[a]]=[i[a],i[e]],o=!0,r(`Row ${e+1} and Row ${a+1} swapped.`);break}if(!o){s.add(e),r(`Variable x${e+1} is a free variable.`);continue}}let m=i[e][e];if(!n(m)){for(let o=0;o<f;o++)i[e][o]/=m;r(`Row ${e+1} divided by ${m.toFixed(2)} to make leading 1.`)}for(let o=0;o<t;o++)if(o!==e&&!n(i[o][e])){let a=i[o][e];for(let S=0;S<f;S++)i[o][S]-=a*i[e][S];r(`Row ${o+1} updated to eliminate variable x${e+1} (multiplied by ${a.toFixed(2)}).`)}}this.steps=v,this.currentStep=0,this.solution=[];for(let e=0;e<t;e++)if(s.has(e))this.solution.push("free");else if(n(i[e][e])){if(!n(i[e][f-1])){this.errorMessage="No solutions exist for this system.";return}}else this.solution.push(i[e][f-1]);s.size>0&&(this.errorMessage="The system has infinitely many solutions due to free variables.")},prevStep(){this.currentStep>0&&this.currentStep--},nextStep(){this.currentStep<this.steps.length-1&&this.currentStep++}}},M={class:"solver-container"},w={class:"input-container"},J={key:0},N={class:"matrix-table"},V=["onUpdate:modelValue"],C={key:1,class:"error-message"},_={key:2},F={class:"matrix-table"},G=["disabled"],R=["disabled"],O={key:3};function U(i,t,f,v,s,n){return p(),u("div",M,[t[10]||(t[10]=l("h2",null,"Gauss-Jordan Method Solver",-1)),t[11]||(t[11]=l("p",null,"Enter the size of the matrix (n x m):",-1)),l("div",w,[t[6]||(t[6]=l("label",{for:"rows"},"Rows (n): ",-1)),y(l("input",{type:"number","onUpdate:modelValue":t[0]||(t[0]=r=>s.rows=r),min:"1"},null,512),[[g,s.rows]]),t[7]||(t[7]=l("label",{for:"cols"},"Columns (m): ",-1)),y(l("input",{type:"number","onUpdate:modelValue":t[1]||(t[1]=r=>s.cols=r),min:"1"},null,512),[[g,s.cols]]),l("button",{onClick:t[2]||(t[2]=(...r)=>n.createMatrix&&n.createMatrix(...r))},"Create Matrix")]),s.matrix.length>0?(p(),u("div",J,[t[8]||(t[8]=l("h3",null,"Matrix (n x m)",-1)),l("table",N,[(p(!0),u(h,null,x(s.matrix,(r,e)=>(p(),u("tr",{key:e},[(p(!0),u(h,null,x(r,(m,o)=>(p(),u("td",{key:o},[y(l("input",{"onUpdate:modelValue":a=>s.matrix[e][o]=a,type:"number"},null,8,V),[[g,s.matrix[e][o],void 0,{number:!0}]])]))),128))]))),128))]),l("button",{onClick:t[3]||(t[3]=(...r)=>n.solveGaussJordan&&n.solveGaussJordan(...r))},"Solve")])):b("",!0),s.errorMessage?(p(),u("div",C,[l("h3",null,"Error: "+d(s.errorMessage),1)])):b("",!0),s.steps.length>0?(p(),u("div",_,[l("h3",null,"Step "+d(s.currentStep+1)+" of "+d(s.steps.length),1),l("p",null,d(s.steps[s.currentStep].action),1),l("table",F,[(p(!0),u(h,null,x(s.steps[s.currentStep].matrix,(r,e)=>(p(),u("tr",{key:e},[(p(!0),u(h,null,x(r,(m,o)=>(p(),u("td",{key:o},d(m.toFixed(2)),1))),128))]))),128))]),l("button",{onClick:t[4]||(t[4]=(...r)=>n.prevStep&&n.prevStep(...r)),disabled:s.currentStep===0},"Previous",8,G),l("button",{onClick:t[5]||(t[5]=(...r)=>n.nextStep&&n.nextStep(...r)),disabled:s.currentStep===s.steps.length-1}," Next ",8,R)])):b("",!0),s.solution&&s.solution.length>0?(p(),u("div",O,[t[9]||(t[9]=l("h3",null,"Solution:",-1)),(p(!0),u(h,null,x(s.solution,(r,e)=>(p(),u("div",{key:e,class:"solution"}," x"+d(e+1)+" = "+d(r!=="free"?r.toFixed(2):"free"),1))),128))])):b("",!0)])}const E=k(c,[["render",U]]);export{E as default};
